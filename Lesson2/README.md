let arr = new Array();
let arr = [];

let fruits = ["Яблоко", {obj: 1}, 1];
console.log(fruits[0]);//Яблоко

fruits[3] = "Груща";
Длина: fruits.length === 4 

let fruits = ["Яблоко", {obj: 1}, 1];

fruits[12] = "Я";

console.log(fruits.length)//13
console.log(fruits)//["Яблоко", {obj: 1}, 1, 'empty'xсвободных ячеек, "Я"]

fruits[-1] // fruits[fruits.length - 1]

fruits.at(-1)


Методы массивов
0
pop, push, shift, unshift

pop - выдавить последний элемент из массива, возвращает последний элемент
fruits.pop() //"Я"

push - вставить элемент в конец массива, возвращает длину массива
fruits.push("Ты") //14

shift - выдавить первый элемент из массива, возвращает первый элемент
fruits.shift() //"Я"

unshift - вставить элемент в начало массива, возвращает длину массива
fruits.push("Ты") //14

//Дополнительные методы

map, filter, reduce, indexOf, slice, splice

map

let arr = [1, 2, 3];

let arr2 = arr.map((elem)=>{
    return elem * 2;
}) // [2, 4, 6]

filter

let arr = [1, 2, 3];

let arr2 = arr.filter((elem)=>{
    return elem % 2 !== 0;
}) // [1, 3]


reduce

let arr = [1, 2, 3];
let arr2 = arr.reduce((a, b)=>{return a + b}, 0) // 6
0 число, с которого начинается операция(к примеру)

Методы arr.reduce и arr.reduceRight похожи на методы выше, но они немного сложнее. Они используются для вычисления единого значения на основе всего массива.

Синтаксис:

let value = arr.reduce(function(accumulator, item, index, array) {
  // ...
}, [initial]);

Функция применяется по очереди ко всем элементам массива и «переносит» свой результат на следующий вызов.

Аргументы:

    accumulator – результат предыдущего вызова этой функции, равен initial при первом вызове (если передан initial),
    item – очередной элемент массива,
    index – его позиция,
    array – сам массив.


indexOf

let arr = [1, 0, false];

alert( arr.indexOf(0) ); // 1
alert( arr.indexOf(false) ); // 2
alert( arr.indexOf(null) ); // -1

alert( arr.includes(1) ); //
Если нет элемента в массиве, вернуть -1

find
let result = arr.find(function(item, index, array) {
  // если true - возвращается текущий элемент и перебор прерывается
  // если все итерации оказались ложными, возвращается undefined
});

Шпаргалка по методам массива:

    Для добавления/удаления элементов:
        push(...items) – добавляет элементы в конец,
        pop() – извлекает элемент с конца,
        shift() – извлекает элемент с начала,
        unshift(...items) – добавляет элементы в начало.
        splice(pos, deleteCount, ...items) – начиная с индекса pos удаляет deleteCount элементов и вставляет items.
        slice(start, end) – создаёт новый массив, копируя в него элементы с индекса start до end (не включая end).
        concat(...items) – возвращает новый массив: копирует все члены текущего массива и добавляет к нему items. Если какой-то из items является массивом, тогда берутся его элементы.

    Для поиска среди элементов:
        indexOf/lastIndexOf(item, pos) – ищет item, начиная с позиции pos, и возвращает его индекс или -1, если ничего не найдено.
        includes(value) – возвращает true, если в массиве имеется элемент value, в противном случае false.
        find/filter(func) – фильтрует элементы через функцию и отдаёт первое/все значения, при прохождении которых через функцию возвращается true.
        findIndex похож на find, но возвращает индекс вместо значения.

    Для перебора элементов:
        forEach(func) – вызывает func для каждого элемента. Ничего не возвращает.

    Для преобразования массива:
        map(func) – создаёт новый массив из результатов вызова func для каждого элемента.
        sort(func) – сортирует массив «на месте», а потом возвращает его.
        reverse() – «на месте» меняет порядок следования элементов на противоположный и возвращает изменённый массив.
        split/join – преобразует строку в массив и обратно.
        reduce/reduceRight(func, initial) – вычисляет одно значение на основе всего массива, вызывая func для каждого элемента и передавая промежуточный результат между вызовами.

    Дополнительно:
        Array.isArray(arr) проверяет, является ли arr массивом.


[1,2,3] === [1,2,3] //false

let arr = ["Яблоко", "Апельсин", "Груша"];

for (let i = 0; i < arr.length; i++) {
    //перебор элементов
}

arr.forEach((elem)=>{

}) 
//более краткая запись


for(let key in arr) // по всем свойствам массива
let arr = ["Яблоко", "Апельсин", "Груша"];
for (let key in arr) {
  alert( arr[key] ); // Яблоко, Апельсин, Груша
}
for(let key of arr) - лучше не использовать